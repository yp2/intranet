Poniższy rozdział omawia implementację aplikacji służącej jako intranet dla firmy z sektora IT, opisane zostaną założenia oraz --wymagania stawanie dla strony serwerowej oraz dla klientów--. W rozdziale poruszone zostaną najistotniejsze oraz kluczowe elementy aplikacji. Aplikacja została napisana z wykorzystaniem frameworka Meteor.js. Część serwera jak i kliencka została za programowana z użyciem JavaScriptu. Warstwa prezentacji została napisana z użyciem HTML5, CSS3/less, Bootstrap oraz AdminLTE. Bazę danych dla aplikacji stanowi nierelacyjna baza danych MongoDB wraz z jej kliencką implementacją Minimongo.

\section{Założenia}
% założenia aplikacji intranet

Jak już wspomniono wcześniej do najważniejszych funkcjonalności aplikacji intranetowych zaliczamy dzielenie wiedzy oraz informacji, komunikację pomiędzy pracownikami danej organizacji oraz wspomaganie pracy zespołowej. W oparciu o ten najważniejsze funkcjonalności budowana aplikacja powinna spełniać następujące założenia:
\begin{itemize}
 \item tworzenie oraz rejestracja organizacji;
 \item tworzenie oraz rejestracja użytkowników;
 \item nazwa użytkownika oraz organizacji to jego emial;
 \item dodawanie utworzonego użytkownika do organizacji;
 \item tworzenie oraz rejestracja użytkowników z wykorzystaniem zaproszeń powiązanych z organizacją;
 \item organizacja w swoim zakresie, powinna posiadać główny zbiór artykułów --- główne wiki\footnote{Typ serwisu internetowego, w którym treść można tworzyć i zmieniać z poziomu przeglądarki internetowej, za pomocą języka znaczników lub edytora WYSIWYG. Strony wiki, ze względu na swoją specyfikę, są przede wszystkim wykorzystywane do pracy nad wspólnymi projektami, takimi jak repozytoria wiedzy na wybrany temat lub projekty różnych grup społecznych};
 \item główne wiki dla organizacji ma być one widoczne dla wszystkich użytkowników należących do danej organizacji; 
 \item główne wiki ma posiadać główną kategorię, której nie można usunąć;
 \item tworzenie, edycja, usuwanie kategorii artykułów w głównej wiki;
 \item tworzenie, edycja, usuwanie artykułów w głównej wiki; 
 \item artykuły mogą być dodawana do głównej kategorii wiki lub do utworzonych przez użytkownika kategorii;
 \item edycja oraz prezentacja artykułów na obsługiwać język znaczników \emph{markdown}\footnote{Język znaczników przeznaczony do formatowania tekstu zaprojektowany przez Johna Grubera i Aarona Swartza. Został stworzony w celu jak najbardziej uproszczenia tworzenia i formatowania tekstu. Markdown został oryginalnie stworzony w Perlu, później dostępny w wielu innych. Jest rozpowszechniany na licencji BSD i jest dostępny jako wtyczka do kilku systemów zarządzania treścią.} w szczególności jego implementację \textit{GitHub Flavored Markdown} --- GFM;
 \item artykuły mogą mieć stan opublikowany oraz do publikacji;
 \item użytkownik nie będący twórcą danej organizacji ma dostęp tylko do artykułów opublikowanych przez innych użytkowników oraz do wszystkich swoich artykułów niezależnie od ich stanu;
 \item organizacja ma dostęp w swoim zakresie do wszystkich artykułów, wszystkich użytkowników należących do danej organizacji niezależnie od stanu ich publikacji;
 \item kategoria, w której są artykuły nie może zostać usunięta;
 \item artykuł może należeć tylko do jednej kategorii;
 \item użytkownik w swoim zakresie posiada główną wiki;
 \item główna wiki dla użytkownika jest widoczna tylko dla niego w jego zakresie;
 \item główna wiki dla użytkownika ma takie same funkcjonalności jak główna wiki dla organizacji;
 \item prezentacja, tworzenie, edycja oraz usuwanie artykułów dla głównego wiki dla użytkownika ma spełniać opisane cechy jak dla artykułów dla organizacji; 
 \item użytkownicy mogą zmieniać zakres w pomiędzy zakresami organizacji, do których należą i swoim zakresem;
 \item organizacja oraz użytkownicy mogą tworzyć, usuwać projekty w swoich zakresach lub zakresach, do których należą;
 \item projekty powinny posiadać stronę z podsumowaniem;
 \item projekty powinny posiadać niezależne wiki;
 \item projekty powinny mieć możliwością dodawania --- zapraszanie --- użytkowników oraz ich usuwanie;
 \item wiki dla projektów ma mieć te same cechy jak główne wiki;
 \item projekty powinny posiadać możliwość komunikacji pomiędzy użytkownikami przynależącymi do danego projektu;
 \item twórca projektu może dodawać oraz usuwać użytkowników, którzy mają do niego dostęp;
 \item użytkownicy widzą tylko projekty, do których zostali zaproszeni;
 \item organizacja ma dostęp do wszystkich projektów utworzonych w jej zakresie;
 \item komunikacja w obrębie projektu mam mieć możliwość dodania wiadomości wraz z jej tytułem oraz możliwością dodana komentarzy;
 \item wysyłanie zaproszeń do projektów oraz organizacji --- jeżeli użytkownik z podanym adresem email istnieje w systemie ma być automatycznie dodany do projektu lub organizacji;
 \item aplikacja ma być dostępna na wszystkich znaczących platformach oraz jak największej ilości urządzeń.
\end{itemize} 

\section{Wymagania}
% tu zobaczym czy to będzie opis ogólnie dlaczego został wybarny meteor a nie inne rozwiązanie - można wspomnieć o szybkości kodowania oraz że tematyka nie stoi w sprzeczości z frameworkiem oraz samym mongo 

Niezależność od platformy oraz dostępność na jak największej ilości urządzeń narzuciła wybór typu aplikacji. Budowana aplikacja będzie typu sieciowego. Klienci będą uzyskiwać do niej dostęp poprzez przeglądarki internetowe kontaktując się z serwerem, na którym będzie dostępna budowana aplikacja. 

W oparciu o założenia jakie ma spełniać aplikacja \emph{Intranet} oraz o obecne trendy w rozwoju aplikacji sieciowych do budowy aplikacji został wybrany framework Meteor.js, a jako język programowania JavaScript. Wybór tych technologii był podyktowany także szybkością oraz prostotą budowania aplikacji. Meteor.js używa JavaScriptu zarówno po stornie klienta oraz serwera co skraca czas nauki samego framework'a eliminując potrzebę nauki dodatkowego języka programowania. Tematyka oraz założenia projektu nie stanowią problemu dla przyjętego przez framework Meteor.js nierelacyjnego rozwiązania bazodanowego. Aplikacja nie posiada krytycznych elementów takich jak transakcje finansowe, zamówienia oraz innych elementów wymagających transakcji operacji na całej bazie danych. Dane są typowo informacyjne w związku z tym wykorzystanie bazy MongoDB nie stanowi żadnego zagrożenia dla użytkowników oraz samej aplikacji.

Aplikacja ma być dostępna na wszystkich znaczących platformach oraz jak największej ilości urządzeń. Aby to zapewnić w warstwie prezentacji wykorzystano HTML5, CSS3 wraz z kompilatorem less oraz domyślnie wykorzystywaną przez Meteor.js bibliotekę JQuery. W celu zachowania responsywności interfejsu użytkownika wykorzystano szablon AdminLTE, który oparty jest o framework Bootstrap. Wykorzystanie Bootstrapa dostarcza prosty oraz szybki sposób na dostosowanie układu i wyglądu interfejsu użytkownika w zależności od używanego przez niego urządzenia. Rozwiązanie to znaczenie zwiększa użyteczność aplikacji podczas używania urządzeń o różnych wielkościach oraz rozdzielczościach ekranu. 

\section{Struktura aplikacji}
%   nie zapomnieć o katalogu .meteor

Aplikacje napisane z wykorzystaniem frameworka Meteor.js to zestaw plików JavaScript, które działają w przeglądarce internetowej i w kontenerze Node.js po stronie serwera, i innych plików pomocniczych takich jak szablony HTML, kaskadowe arkusze stylów oraz statycznych zasobów. Meteor.js automatycznie pakuje oraz zajmuję się przesyłaniem tych różnych elementów. Framework jest dość elastyczny jeżeli chodzi o strukturę katalogów w jakiej będą umieszczone poszczególne elementy aplikacji. Nazwy plików jaki i katalogów mogą mieć wpływ na to w jakiej kolejności są one ładowane oraz gdzie są one ładowane. Meteor.js niektóre katalogi traktuje w specjalny sposób.

Katalogi o nazwie \verb|client| nie są ładowane po stronie serwera. Wszystkie zasoby znajdujące się w tym katalogu gdy aplikacja nie jest uruchomiona w trybie produkcyjnym są łączone oraz minimalizowane. W trybie developerskim plik JavaScript oraz CSS nie są minimalizowane aby ułatwić znajdowanie błędów w aplikacji. Jednakże pliki CSS nadal są łączone w jeden plik. Pliki HTML po stronie klienta są skanowane w poszukiwaniu trzech elementów najwyższego poziomu \verb|<head>|, \verb|<body>|, \verb|<template>|. Elementy head oraz body łączone są w jeden element i następnie przesyłane do klienta podczas pierwszego ładowania strony.

Zasoby znajdujące się w katalogach o nazwie \verb|server| nie są ładowane po stronie klienta. Krytyczne oraz wrażliwe elementy aplikacji takie jak zarządzenia hasłami, proces autoryzacji powinny znajdować się w tych katalogach. Meteor zbiera wszystkie pliki JavaScript za wyjątkiem tych znajdujących się w katalogach \verb|public|, \verb|client| i \verb|private| oraz ich podkatalogach i ładuje je do instancje Node.js znajdującej się na serwerze. Kod na serwerze nie jest uruchamiany jako kod asynchroniczny typowy dla aplikacji opartych o Node.js. Meteor uruchamia kod pojedynczy wątek na żądanie

Wszystkie pliki znajdujące w katalogu \verb|public| najwyższego poziomu serwowane są dla klientów takim jakimi są. Jest to właściwe miejsce dla plików takich jak \verb|favicon.ico|, \verb|robots.txt| oraz innych podobnych plików.

Pliki znajdujące się w katalogu najwyższego poziomu o nazwie \verb|private| dostępne są tylko po stronie serwera z wykorzystaniem API \verb|Assets|. Katalog ten przeznaczony jest dla takich plików jak prywatne dane oraz plików, które nie mają być dostępne z zewnątrz.

Wszystkie pliki JavaScript nie znajdujące się w specjalnych katalogach ładowane są zarówno po stronie klienta jaki i serwera. Jest to dobre miejsce na definicje modeli oraz innych funkcji, które mają być dostępne zarówno dla klienta jak i serwera. Meteor.js dostarcza zmienne \verb|Meteor.isClient| oraz \verb|Meteor.isServer|, które można użyć do zmiany zachowania w zależności czy kod jest uruchomiony na serwerze czy kliencie. Pliki CSS oraz HTML poza specjalnymi katalogami ładowane są tylko po stornie klienta i nie mogą zostać użyte po stronie serwera.

\section{Cześć wspólna dla serwera oraz klienta}
  \subsection{Metody}
  \subsection{Kolekcje} 
    definicja kolekcji, plus opis collection hooks oraz sposoby impelentacji relacyjności plus przykłady z aplikacji
    
    
\section{Serwer}
  \subsection{Baza}
  \subsection{Kolekcje}
  \subsubsection{Dostęp}
   allow/deny
   \subsubsection{Metody}
   \subsubsection{Publikacje}
% \subsection{Publikacje}
  \subsection{Migracje danych}
  \subsection{Konfiguracja}



\section{Klient}
  \subsection{Routing}
  \subsection{Subskrypcje}
  \subsection{Szablony}
    \subsubsection{HTML}
    \subsubsection{JS}
  \subsection{Eventy}
  \subsection{Helpery}
  \subsection{Pliki less}
    że są zbierane w całość i łączone w jeden duży plik.
  \subsection{Formularze}
    opis jak to jest obsługiwane plus yfform
  
\section{Objekt MyApp}
  po co go się stosuje

  
\section{Paczki powtstałe na potrzeby aplikacji}
yp2:admin-lte@2.3.1
yp2:confirm-modal-bs3@1.1.1
yp2:hijack-email@1.0.0
yp2:yfform@0.3.10
plus informacje że są one dostępne na Atmosfer i githubie