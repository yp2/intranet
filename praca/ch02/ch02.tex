Rozdział ten przedstawia wykorzystane technologie oraz języki programowania użyte podczas projektowania oraz programowania aplikacji Intranet. Aplikacja powstała z wykorzystaniem \emph{JavaScript}, frameworka aplikacji sieciowych \emph{Meteor.js}, nierelacyjnej bazy danych  \emph{MongoDB}, \emph{HTML5}, \emph{CSS3}, \emph{less}\footnote{Dynamiczny język arkuszy stylów}, frameworka CSS \emph{Bootstrap} oraz gotowego szablon dla panelu administracyjnego \emph{AdminLTE} wykorzystujący Bootstrap.

\section{JavaScript}

Język programowania JavaScript został użyty do zaprogramowania zarówno części serwerowej (\textit{back-end}) jaki i części odpowiedzialnej za interakcje z użytkownikiem (\textit{front-end}) --- interfejs użytkownika. Obecne strony WWW a w szczególności aplikacje dostępne przez przeglądarkę (Gmail, Google Docs, Google Maps, Facebook) szeroko korzystają z~JavaScript w celu dostarczenie wielofunkcyjnego oraz interaktywnego interfejsu użytkownika. Jednym z powodów wykorzystanie JavaScript była możliwości wykorzystania go po stornie serwera oraz klienta. Najpopularniejszy obecnie sposób tworzenia stron/aplikacji internetowych wyróżnia trzy warstwy --- warstwę struktury (HTML), warstwę prezentacji (CSS) oraz warstwę zachowania (JavaScript)\cite{stefanov10}.

Internet powstał jako zbiór statycznych dokumentów HTML, które były powiązane hiperłączami. Po wzroście popularności oraz rozmiaru sieci, autorom stron przestały wystarczać dostępne narzędzia. Widoczna stała się potrzeba poprawienia interakcji z~użytkownikiem. U jej podstaw leżała chęć zmniejszenia ilości połączeń z serwerem w celu realizowania prostych zadań takich jak np. walidacja formularzy. W tym czasie pojawiły się dwie możliwości rozwiązania tego problemu --- aplety Javy oraz język \emph{LiveScript}, który został zaproponowany przez firmę Netscape w roku 1995. Został on dołączony do przeglądarki Netscape 2.0 pod nazwą JavaScript\cite{stefanov10}.  

Możliwość modyfikacji statycznych elementów stron internetowych bardzo szybko została przyjęta przez rynek. Producenci przeglądarek internetowych szybko dostosowali swoje produktu do obsługi JavaScript'u. Microsoft wyposażył w taką obsługę swoją przeglądarkę Internet Explorer (IE) od wersji 3.0. Była to jednak kopia języka JavaScript --- \emph{JScript}, wzbogacona o kilka funkcjonalności przeznaczonych tylko dla IE. W wyniku coraz większych różnić pomiędzy przeglądarkami podjęto próbę standaryzacji różnych implementacji języka. Zadanie to przypadło  Europejskiemu Stowarzyszeniu na rzecz Systemów Informatycznych i Komunikacyjnych (ECMA). Tak powstała specyfikacja ECMAScript. Obecnie obowiązuje standard ECMA-262\cite{ecmascriptWiki} --- jego najpopularniejszą implementacją jest JavaScript.  

Wzrost popularności JavaScriptu nastąpił w czasie Pierwszej Wojny Przeglądarek (1996-2001)\cite{stefanov10}. Okres ten nazywany jest także okresem bańki internetowej. W tym czasie o udział w rynku walczyli dwaj główni producenci przeglądarek Netscape oraz Microsoft. Firmy kusiły klientów za pomocą coraz to nowych dodatków i ozdóbek wprowadzanych do przeglądarek oraz do stosowanych w nich wersji JavaScriptu. W tym czasie wiele osób wyrobiło sobie negatywną opinie na temat tego języka, który w wyniku wspomnianych działań oraz braku standaryzacji bez przerwy ulegał zmianie. Pisanie programów było koszmarem. Skrypty napisane w oparciu o jedną przeglądarkę nie chciały działać w drugiej. Producenci przeglądarek, skupieni na rozszerzaniu o nowe funkcjonalności, nie dostarczali odpowiednich narzędzi do rozwijania aplikacji\cite{stefanov10}.

Niespójności pomiędzy przeglądarkami była tylko częścią problemu. Drugą częścią byli sami autorzy stron, którzy upychali w witrynach zbyt wiele zbędnych funkcjonalności. Bardzo często korzystali z wszystkich nowych możliwości dostarczanych przez przeglądarkę, przez co strony były ,,upiększane'' o kwiatki takie jak animacje na pasku stanu, jaskrawe kolory, migające napisy, trzęsące się okna przeglądarek, płatki śniegu, obiekty podążające za kursorem itp., co bardzo często utrudniało korzystanie ze stron. Tego typu nadużycia są także powodem złej reputacji JavaScriptu. Problemy te doprowadziły do traktowania języka JavaScript za niewiele więcej niż zabawkę przeznaczoną dla projektantów interfejsów. 

% Sprzeciw wobec JavaScriptu doprowadził do sytuacji, w której w niektórych projektach sieciowych zabronione zostało jakiekolwiek programowanie po stronie klienta. Wszystkie funkcjonalności miał obsługiwać przewidywalny i wiarygodny serwer.

Po zakończeniu Pierwszej Wojny Przeglądarek sposób wytwarzania aplikacji sieciowych uległ zmianie. Zmiany --- na lepsze --- zostały zapoczątkowane przez kilka procesów\cite{stefanov10}: 
\begin{itemize}
 \item Microsoft wygrał wojnę i na okres około pięciu lata wstrzymał się od dodawania nowych funkcjonalności do przeglądarki Internet Explorer oraz do samego JavaScriptu. Dzięki temu producenci innych przeglądarek zyskali czas na dogonienie a czasem nawet przewyższenie możliwości IE.
 \item Ruch na rzecz standardów sieciowych zyskał przychylność programistów jaki i producentów przeglądarek. Standardy chronią programistów od konieczności programowania funkcjonalności dwa (lub więcej) razy na wypadek, gdyby coś nie działało, w którejś z przeglądarek. Co prawda nadal nie istnieje środowisko, które spełniało by wszystkie możliwe standardy.
 \item technologie i sposoby programowania osiągnęły bardzo dojrzały poziom, na którym można już zajmować się zagadnieniami takim jak użyteczność, dostępność czy też progresywne ulepszanie. 
\end{itemize}
Dzięki nowym, zdrowszym metodologiom programiści zaczęli uczyć się lepszych sposób korzystania z już dostępnych narzędzi. Po wydaniu aplikacji takich jak \emph{Gmail} czy \emph{Google Maps}, które w bardzo szerokim stopniu korzystają z programowania po stronie klienta, stało się oczywiste, że JavaScript to dojrzały, jedyny w swoim rodzaju oraz potężny prototypowy język obiektowy\cite{stefanov10}. Dobrym przykładem jego ponownego odkrycia jest szeroka akceptacja funkcjonalności dostarczanej przez obiekt \jsinline{XMLHttpRequest}, który dawniej był obsługiwany tylko przez przeglądarkę Internet Explorer. Obiekt ten jednak został zaimplementowany przez wiele przeglądarek. \jsinline{XMLHttpRequest} umożliwia wykonywanie żądań HTTP i pobieranie zawartości serwera w celu aktualizacji pewnych części strony bez konieczności przeładowanie jej całej. Dzięki temu narodził się nowy gatunek aplikacji sieciowych, które przypominają samodzielne aplikacje desktopowe. Takie aplikacje określamy mianem aplikacji \emph{AJAX}.

JavaScript po rewolucji spowodowanej rozwojem technologii AJAX zaczął być używany przez programistów do tworzenia rzeczywistych i ważnych aplikacji. Obecnie mamy wiele aplikacji sieciowych JavaScript począwszy od Twittera, przez Facebook, aż po GitHub\cite{cantelon14}. Jedną z ciekawszych cech JavaScriptu jest to, że musi on działać wewnątrz \emph{środowiska}. Najpopularniejszym środowiskiem jest przeglądarka internetowa. Istnieją także inne możliwości --- JavaScript może działać po stornie serwera, na pulpicie lub wewnątrz tzw. \emph{rich media}\footnote{Aplikacje \textit{rich media} --- Flash, Flex --- tworzy się przy użyciu ActionScriptu, który jest oparty o ECMAScript}. 

Od chwili wydania przeglądarki Google Chrome w roku 2008 ciągle i w bardzo szybkim tempie poprawia się wydajność działania JavaScript, co jest wynikiem silnej konkurencji pomiędzy producentami poszczególnych przeglądarek internetowych. Wydajność nowoczesnych maszyn wirtualnych JavaScript zmienia rodzaje aplikacji tworzonych dla sieci. Fantastycznym przykładem jest jslinux\footnote{\url{http://bellard.org/jslinux/}} --- utworzony w JavaScript emulator pozwalający na wczytanie jądra systemu Linux, pracę w powłoce oraz kompilację programów w C.

\subsection{Przegląd cech JavaScript}

JavaScript jest imperatywnym oraz strukturalnym językiem programowania. Wspiera większość składni programowania strukturalnego z języka C, np. pętle \verb|while|, instrukcję wyboru \verb|switch|, pętle \verb|do while| oraz wiele innych. Wyjątkiem jest zasięg zmiennych. W JavaScript zasięg zmiennych z wykorzystaniem słowa kluczowego \verb|var| to zasięg do całego ciała funkcji. Nowy standard ECMAScript 2015 (ES6) wprowadza zakres zmiennych co do bloku instrukcji z wykorzystaniem słowa kluczowego \verb|let| --- co oznacza że język ten ma obecnie zakres zmiennych co do ciała funkcji jak i do bloku instrukcji. Podobnie jak C JavaScript rozróżnia wyrażenia oraz instrukcji\cite{jsWiki}. 

Jak większość języków skryptowych także JavaScript jest językiem dynamicznie typowanym. Typy powiązane są z wartościami a nie ze zmiennymi. Na przykład do zmiennej x może być przypisana wartość typu liczbowego a następnie możemy do takiej zmiennej przypisać na przykład łańcuch znaków\cite{jsWiki}. 

JavaScript jest prawie w całości obiektowy. Obiekty w JavaScript są to tablice asocjacyjne rozszerzone o prototypy. Nazwy właściwości obiektu to ciągi znaków. Obiekty wspierają dwie różnoznaczne składnie --- z kropką \verb|obj.x = 10| oraz z nawiasami kwadratowymi \verb|obj["x"] = 10|. Właściwości oraz ich wartości mogą być dodawane, zmienianie oraz usuwane w każdej chwili działania programu. Większość właściwości obiektu ( oraz te dziedziczone w łańcuch prototypów) mogą być wymienione z wykorzystaniem pętli \verb|for ... in|. JavaScript ma dość skromny wachlarz obiektów wbudowanych, między innymi \verb|Function| (funkcje) oraz obiekty daty --- \verb|Date|. JavaScript oferuje również wbudowaną funkcje \verb|eval|, która może wykonywać instrukcje dostarczone w postaci ciągów znaków podczas działania programu\cite{jsWiki}. 

JavaScript jest także językiem funkcyjnym. Funkcję są typu pierwszej klasy. Oznacza to, że JavaScript wspiera przekazywanie funkcji jako argumentów do innych funkcji, zwracania ich jako wartości innych funkcji, przypisywania ich do zmiennych oraz zapisywanie ich w strukturach danych. JavaScript wspiera również funkcje anonimowe\cite{fcfunctionWiki}. Funkcje w JavaScript jako takie posiadają właściwości oraz metody takie jak \verb|.call()| i \verb|bind|. Funkcje zagnieżdżone to funkcje zdefiniowane wewnątrz innych funkcji. Funkcja taka jest każdorazowo tworzona podczas wywołania funkcji zewnętrznej, w której została ona zdefiniowana. Dodatkowo każda tworzona funkcja tworzy \emph{domknięcie}: zasięg zmiennych funkcji zewnętrznej, włączając w to zmienne lokalne oraz wartości argumentów, stają się częścią wewnętrznego stanu każdego wewnętrznego obiektu funkcji, nawet po zakończeniu wykonywania zewnętrznej funkcji\cite{jsWiki}.

JavaScript w procesie dziedziczenia wykorzystuje prototypy, w odróżnieniu od innych języków zorientowanych obiektowo wykorzystujących klasy. W JavaScript wykorzystując prototypy można za symulować wiele cech dziedziczenia opartego na klasach\cite{jsWiki}. Nowe wydanie ES6 wprowadza do JavaScript składnie umożliwiającą definiowanie klas.  

Funkcje obok swojej typowej roli w JavaScript mogą także tworzyć obiekty. Poprzedzając wywołanie funkcji instrukcją wbudowaną \verb|new| zostanie utworzona instancja prototypu dziedzicząca właściwości oraz metody z konstruktora (włączając w to właściwości z prototypu obiektu wbudowanego \verb|Object|). ECMAScript 5 oferuje metodę \verb|Object.create| pozwalającą na jawne tworzenie instancji bez automatycznego dziedziczenia z prototypu \verb|Object|. Właściwość \verb|prototype| konstruktora określa jaki obiekt zostanie użyty jako wewnętrzny prototyp nowo utworzonego obiektu. Nowe metody mogą zostać dodane poprzez modyfikowanie prototypu funkcji użytej jako konstruktor. Wbudowane konstruktory takie jak \verb|Array| lub \verb|Object|, także posiadają prototyp, który może być modyfikowany. Modyfikowanie prototypy \verb|Object| jest uznawane za złą praktykę ponieważ prawie wszystkie obiekty w JavaScript dziedziczą metody oraz właściwości z prototypu obiektu \verb|Object|\cite{jsWiki}.

W odróżnieniu od wielu języków zorientowanych obiektowo w JavaScript nie ma różnicy pomiędzy definicją funkcji oraz definicją metody. Różnica pojawia się podczas wywołania funkcji oraz metody. Kiedy funkcja wywoływana jest jako metoda obiektu, słowo kluczowe \verb|this| wewnątrz ciała funkcji jest powiązane z obiektem na rzecz, którego dana metoda została wywołana\cite{jsWiki}. 

JavaScript posiada wbudowane implementacje, oparte na funkcjach, wzorców takich jak \textit{cecha} oraz \textit{domieszka}. Jawna, oparta na funkcjach, delegacja nie wspiera kompozycji, natomiast nie jawna delegacja ujawnia się za każdym razem gdy przechodzony jest łańcuch prototypów np. w celu znalezienia metody, która nie należy bezpośrednio do obiektu. Gdy metoda zostanie odnaleziona wywoływana jest w kontekście danego obiektu. Dlatego dziedziczenie w JavaScript jest realizowane przez delegacje, która polega na przypisaniu właściwości do prototypu konstruktora funkcji\cite{jsWiki}.

Typowo JavaScript uruchamiany jest w jakimś środowisku np. w środowisku przeglądarki internetowej, które dostarcza obiekty oraz metody, przez które uruchamiany skrypt może oddziaływać na środowisko np. obiekt DOM strony internetowej. 

JavaScript przetwarza wiadomości z kolejki --- po jednej na raz. Podczas ładowania nowej wiadomości, JavaScript wywołuje funkcję powiązaną z daną wiadomości tworząc ramkę stosu wywołania (są to argumenty funkcji oraz zmienne lokalne). Stos wywołania zmniejsza się oraz powiększa zgodnie z potrzebami wywołanej funkcji. Nazwane jest to pętlą zdarzeń, opisywaną także jako ,,działaj do ukończenia'', ponieważ każda wiadomość jest całkowicie przetwarzana zanim przejdziemy do kolejnej wiadomości. Jednakże wbudowany model konkurencji nadaje pętli zdarzeń charakter nie blokujący. Operacje wejścia/wyjścia realizowane są z użyciem zdarzeń oraz wywołań zwrotnych (funkcji zwrotnych). Oznacza to, że JavaScript może przetworzyć kliknięcie myszy podczas czekania na dane z zapytania do bazy danych\cite{jsWiki}

Do funkcji może zostać przekazana nie określona ilość argumentów. Funkcja ma do nich dostęp poprzez parametry oraz także przez lokalny obiekt \verb|arguments|\cite{jsWiki}.

Jak wiele języków skryptowych, tablice jak i obiekty mogą zostać utworzone przez zwięzłą składnie. Te literały stanowią także podstawę formatu \emph{JSON}\footnote{JavaScript Object Notation - lekki format wymiany danych komputerowych, jest to format tekstowy. Opisany w RFC 4627}\cite{jsWiki}.

JavaScript wspiera również wyrażenia regularne w sposób podobny do \emph{Perl}, z zwięzła oraz bogatą składnią do manipulowania tekstem, znacznie bardziej zaawansowaną niż wbudowane funkcje do obróbki łańcuchów znaków.

\section{Meteor.js}

Meteor.js (Meteor, MeteorJS) jest to otwarto źródłowy framework aplikacji sieciowych napisany w JavaScript z wykorzystaniem \emph{Node.js}. Meteor pozwala na szybkie prototypowanie oraz tworzenie między platformowego kodu (aplikacje sieciowe, Android, iOS). Framework wykorzystuje \emph{MongoDB}, używa protokołu \emph{DDP}\footnote{Distributed Data Protocol - protokół klient--serwer dla zapytań oraz aktualizacji bazy danych po stronie serwera oraz synchronizacji tych aktualizacji wśród innych klientów} oraz wzorca \emph{publikacji i subskrypcji} do automatycznej propagacji zmian w danych do klientów bez potrzeby pisanie kodu synchronizującego taką propagację. Po stronie klienta, Meteor wykorzystuje \emph{jQuery}. Meteor jest rozwijany prze \textit{Meteor Development Group}. Meteor po raz pierwszy został publicznie pokazany w grudniu 2011 pod nazwą \textit{Skybreak}\cite{meteorWiki}.

Meteor jest niepokojącą (w dobrym znaczeniu) technologią. Umożliwia budowanie aplikacji nowego typu, które są szybsze oraz prostsze w tworzeniu. Wykorzystuje nowoczesne techniki takie jak reaktywność po stronie klienta oraz serwera (\textit{Full Stack Reactivity}), kompensacja opóźnień (\textit{Latency Compensation}) oraz \textit{data on the wire} - Meteor nie wysyła danych w postaci HTML, serwer wysyła dane i pozwala klientowi je renderować\cite{strack15}.

% Nasz świat się zmienia. Rzeczy, które nie były możliwe kilka lata temu dzięki kolejnym postępom w dziedzinach takich jak wyświetlacze, technologie informatyczne oraz pojemności nośników danych dziś są nie tylko możliwe ale wręcz niezbędne aby aplikacja odniosła sukces. 

Meteor pozostaje wierny następującym zasadom\cite{meteorDocs}: 
\begin{itemize}
 \item \textit{Data on the Wire} --- Meteor nie wysyła HTML przez sieć. Serwer wysyła dane i pozwala klientowi je renderować.
 \item \textit{Jeden język} --- Meteor pozwala pisać stronę klienta jak i serwera w języku JavaScript.
 \item \textit{Wszechobecna baza danych} --- Meteor pozwala na użycie tych samych metod dostępu do danych po stronie klienta oraz serwera.
 \item \textit{Kompensacja opóźnień} --- Po stronie klienta Meteor wstępnie pobiera dane oraz symuluje modele aby wykonywane metody serwerowe zwracały wynik natychmiast.
 \item \textit{Korzysta z ekosystemu} --- Meteor jest projektem otwarto źródłowym (open source) oraz integruje się z istniejącymi otwarto źródłowymi narzędziami oraz frameworkami.
 \item \textit{Prostota to produktywność} --- Najlepszym sposobem aby coś wyglądało na proste to zrobić to tak aby było proste. Główne funkcjonalności Meteora mają czyste, klasycznie piękne API.
\end{itemize}

Koncepcja ,,danych w kablu`` \emph{Data On the Wire} jest bardzo prosta i powstała z zagnieżdżonego wzorca model -- widok -- kontroler --- \textit{MVC}. Zamiast przetwarzania przez serwer każdego żądania, renderowania treści i wysyłania HTML do klienta, serwer wysyła same dane i pozowana klientowi zdecydować co z nimi zrobić\cite{strack15}.

To rozwiązanie w Meteorze zostało zaimplementowane z użyciem \emph{Distributed Data Protocol} (DDP) --- protokołu klient -- serwer dla zapytań oraz aktualizacji danych po stronie serwera w bazie danych oraz synchronizacji tych zmian pośród innych klientów. Protokół ten oparty jest o składnie JSON oraz komunikuje się z serwerem w sposób podobny do protokołu \emph{REST}\footnote{Representational State Transfer - (zmiana stanu poprzez reprezentacje) --- styl architektury oprogramowania powstały z doświadczeń podczas opracowywania specyfikacji protokołu HTTP dla systemów rozproszonych. REST wykorzystuje między innymi jednorodny interfejs, bezstanową komunikację, zasoby, reprezentacje, hipermedia\cite{restWiki}}. Dodawanie, usuwanie oraz aktualizację są rozsyłane przez sieć oraz obsługiwane przez docelowe urządzenia, usługi oraz klientów. DDP używa \emph{WebSockets}\footnote{Technologia zapewniająca dwukierunkowy kanał komunikacji za pośrednictwem jednego gniazda TCP. Stworzona głównie jako kanał komunikacji pomiędzy przeglądarką internetową a serwerem internetowym. Może być także stosowana w innych aplikacjach typu klient lub serwer.\cite{wsWiki}} zamiast HTTP, dane pomogą być wysyłane kiedy tylko dane ulegną modyfikacji\cite{strack15}.

Najważniejszą zaletą protokołu DDP to sposób komunikacji. Nie ma znaczenie jaki system wysyła lub odbiera dane może to być serwer, klient, usługa sieciowa - wszystkie one używają tego samego protokołu. Oznacza to, że żaden z systemów nie wiem czy inne systemy to serwery czy klienci. Z wyjątkiem przeglądarki, każdy z systemów może być serwerem lub pełnić role klienta. Cały ruch generowany przez protokół wygląda tak samo i jest traktowany w ten sam sposób. Tradycyjna koncepcja jednego serwera dla jednego klienta staje się przestarzała. Możliwe jest połączenie wielu serwerów, które pełnią określone role. Klient może być połączony z wieloma serwerami, z którymi może pracować w różny sposób\cite{strack15}. 

W skład frameworka wchodzi także ciekawa technologia --- \emph{mini baza danych}. Jest to ,,leka'' wersja normalnej bazy danych rezydującej w pamięci po stronie klienta. Klient zamiast wysyłać żądania do serwera może zmieniać dane bezpośrednio w mini bazie danych, które znajduje się po stronie klienta. Po aktualizacji danych w mini bazie danych ta automatycznie synchronizuje się z serwerem, który posiada właściwą bazę danych, wykorzystując protokół DDP. Meteor w roli mini bazy danych wykorzystuje \emph{Minimongo}, właściwa baza po stronie serwera to \emph{MongoDB}\cite{strack15}.

Aktualizacja danych po stronie klienta, najpierw jest realizowana w instancji Minimongo. Klient pozostawia synchronizację zmian Minimongo (z wykorzystaniem protokołu DDP). Jeżeli serwer zaakceptuje zmiany, rozsyła je do wszystkich połączonych klientów, włączając w to także tego, który dokonał zmian. Natomiast jeżeli serwer odrzuci zmiany, bądź pojawi się nowszy zestaw danych od innego klienta, Minimongo na kliencie zostanie skorygowane, co spowoduje aktualizację wszystkich elementów interfejsu użytkownika powiązanych z tymi danymi. Rozwiązanie to w połączeniu z asynchronicznością (realizowaną z wykorzystaniem DDP) jest przełomowe. Oznacza to, że klient nie musi czekać na odpowiedź z serwera. Klient aktualizuje interfejs użytkownika w oparciu o dane zawarte w instancji Minimongo. W przypadku gdy aktualizacja danych została odrzucona przez serwer lub inne zmiany dotarły z serwera, klient zostanie zaktualizowany zaraz po otrzymaniu takiej informacji z serwera.

W przypadku powolnego połączenia z internetem lub jago całkowitego jego braku Meteor kompensuje to poprzez wysyłanie danych do Minimongo oraz natychmiastowymi zmianami w interfejsie użytkownika. W normalnym środowisku klient -- serwer żadna aktualizacja nie została by wykonana, interfejs użytkownika pokazywał by stan ładowania podczas kiedy klient czekał by na odpowiedź z serwera. Wszystkie dokonane zmiany miałby swoje odzwierciedlenie w interfejsie użytkownika w oparciu o Minimongo. Kiedy połączenie z Internetem zostało by przywrócone, wszystkie zakolejkowane zmiany zostaną wysłane na serwer, serwer natomiast prześle autoryzowane zmiany do klienta. Meteor pozwala klientom ,,brać informacje na wiarę''. Jeżeli napotkamy problem to dane otrzymane z serwera naprawią nieścisłości. Jednak przez większość czasu zmiany dokonywane na kliencie są natychmiast wysłane na serwer oraz przez niego rozgłaszane do innych klientów. Aby osiągnąć takie zachowanie należy zdefiniować nową kolekcję w poniższy sposób: 
\begin{js}[caption={Definicja kolekcji}]
  Articles = new Mongo.Collection("Articles")
\end{js}
Ta jedna linijka deklaruje kolekcję \verb|Articles|, której swoją wersję będą posiadały zarówno klient jak i serwer --- lecz traktują ją w odmienny sposób. Klient subskrybuje zmiany ogłaszane przez serwer i aktualizuje odpowiednio swoją kolekcję. Serwer natomiast publikuje zmiany oraz nasłuchuje zmian z klientów aktualizując swoją kolekcję.

Jedną z najważniejszych cech Meteora jest reaktywność. Po stornie klienta, Meteor oferuje bibliotekę \emph{Blaze}, która używa szablonów HTML oraz \emph{helper'ów}\footnote{Pomocniczy kod JavaScript głównie zwracający wartości do szablonu HTML} JavaScript do wykrywania zmian oraz renderowania danych. Kiedy dane zostaną zmienione, helpery same ponowienie się uruchamiają zmieniając, usuwając lub dodając właściwe elementy interfejsu użytkownika na podstawie struktury zapisanej w szablonach. Funkcje, które same ponownie się uruchamiają zaliczane są do \emph{reaktywnych obliczeń}\cite{strack15}.   

Meteor oferuje reaktywne obliczenia zarówno po stronie serwera jak i klienta, bez potrzeby odwoływania się do interfejsu użytkownika. Wchodząca w skład framework'a biblioteka \emph{Tracker} oraz jej helpery także wykrywają zmiany w danych oraz potrafią się same ponownie uruchomić. Ponieważ JavaScript używane jest po stronie serwera oraz klienta, bibliotekę Tracker można używać po obu stronach. Ponieważ używamy tego samego języka po stronie klienta (oraz możemy używać tego samego kod) jak i serwera nazywamy to \emph{full stack reactivity} - reaktywność po stronie klienta jak i serwera.

Ponowne uruchamianie funkcji gdy dane ulegną zmianie ma bardzo dużą zaletę dla programisty. Kod pisany jest deklaratywnie, Meteor sam zajmuję się reaktywnością. Programista określa jak dane mają byś wyświetlane a Meteor sam zajmuję się zmianami w danych. Ten deklaratywny sposób pisania, zazwyczaj osiągany jest z wykorzystaniem szablonów. Szablony działają w oparciu o wiązanie danych z widokiem\footnote{View data bindings} --- są to współdzielone dane, które w zależności od ich zmian będą przedstawiane w różny sposób\cite{strack15}. 

\section{MongoDB}

Meteor po stronie serwera używa MongoDB, po stronie klienta używana jest Minimongo --- wersja MongoDB. Meteor może używać innych baz NoSQL\footnote{Not Only SQL} lub baz zorientowanych na dokumenty. Dzięki użyciu MongoDB programy stają się prostsze, łatwiejsze w tworzeniu. MongoDB doskonale sprawdza się jako szybki oraz lekki magazyn danych.

Tradycyjnie większość danych przechowywana jest z użyciem modelu relacyjnego z wykorzystanie relacyjnych baz danych. Relacyjny model wraz ze wszystkimi powiązanymi z nim zasadami, relacjami, logiką oraz składania jest integralną oraz nieocenioną częścią współczesnej informatyki. Sztywna struktura baz relacyjnych, z dokładnymi wymaganiami co do każdego rekordu, relacje oraz asocjacje umożliwiają szybkie wyszukiwanie, skalowalność oraz dostarczają potencjał do głębszej analizy danych.

Taka dokładność nie jest zawsze potrzebna. Dla prostych aplikacji, pełno wymiarowa relacyjna baza była by nad wymiarowa. W niektórych sytuacjach bardzie efektywne jest wykorzystanie elastycznego mechanizmu przechowywania danych, który umożliwia łatwe rozszerzanie schematu danych bez potrzeby znaczących zmian w tworzonym programie.

Jeżeli byśmy chcieli dodać nową właściwość do obiektu \verb|Article| o wiele łatwiejsze było by dodanie takiej właściwości do obiektu i zrzucenie tego na bazę danych niż przepisanie kodu dotyczącego baz danych, dodanie kolumny, aktualizacja wszystkich zapytań SQL oraz upewnienie się, że wszystkie poprzednie wpisy mają nową właściwość. 

W takich sytuacjach bardzo dobrze sprawdzają się bazy danych zorientowane na dokument. W tym typie baz danych dane zapisywane są w postaci dokumentów złożonych z par klucz -- wartość. Tak przechowywane dokumenty nie muszą mieć z góry ustalonej struktury. Dokumenty mogą przyjmować różne struktury, w kluczach mogą być przechowywane różne wartości --- dla bazy danych nie jest to żadne problem. Jednak każdy dokument musi posiadać unikalny klucz za pomocą, którego może on zostać pobrany z bazy danych\cite{strack15}.
Dla przykładu, jeden dokument może mieć bardzo prostą postać:
\begin{verbatim}
{name: phone_number}
\end{verbatim}
Następny dokument może przybrać formę bardziej skomplikowaną (wewnątrz tej samej bazy danych oraz kolekcji) --- składający się z zagnieżdżonych list, obiektów oraz innych elementów\cite{strack15}:
\begin{verbatim}
{ people: [
  {
    firstname:"STEVE", 
    lastname:"Scuba", 
    phones :[
      {type:cell, number:8888675309},
      {type:home, number:8005322002}
    ]
  },
    {
      firstname:...
	...
  }]
}
\end{verbatim}
Dokumenty mogą przybierać dowolną strukturę, o ile każdy z nich posiada unikalny klucz, umożliwiający ich pobranie. Brak struktury wpływa negatywnie na wydajność zapytań, sortowania oraz aktualizowania dokumentów. Podczas tworzenia aplikacji możemy zidentyfikować najczęściej pojawiające się zapytania i zmodyfikować tak strukturę dokumentów by baza była w niektórych zastosowaniach znacznie wydajniejsza od rozwiązań relacyjnych. Dodatkową zaletą wykorzystania takich baz jest szybkość oraz łatwość pisania aplikacji\cite{strack15}.
Duża elastyczność baz zorientowanych na dokumenty ułatwia szybkie i łatwe zmiany a dostarczane wraz z Meteorem biblioteki pozwalają nie martwić się o połączenie oraz strukturę bazy danych. Jedynie to co jest potrzebne to wysoko poziomowe zrozumienie jak wyszukać, dodać oraz zmodyfikować dokumenty, resztą zajmie się sam Meteor.

MongoDB to otwarto źródłowa baz danych typu NoSQL. Jest to baz danych zorientowana na dokumenty z zaawansowanymi funkcjonalnościami takim jak indeksy, replikacje, zapytania ad-hoc, agregacja danych, zapytania do zagnieżdżonych dokumentów, równoważenie obciążenia, możliwość zapisywania plików. Cechuję ją duża skalowalność, wydajność, brak określonej struktury. Została napisana w języku C++. Dane zapisywane są jako dokumenty w stylu JSON. Taki sposób umożliwia aplikacją bardziej naturalne ich przetwarzanie, przy zachowaniu możliwości tworzenia hierarchii oraz indeksowania. Wewnętrzny język do definiowania zapytań oraz funkcji agregujących to JavaScript wykonywany bezpośrednio przez serwer MongoDB. Dokumenty zapisywane są w MongoDB w logicznych grupach nazywanych kolekcjami.

MongoDB posiada ograniczone wsparcie dla transakcji --- zasięg jest ograniczony do jednego dokumentu. Zmiany w tym dokumencie mogą być bardzo skomplikowane. Z tego powodu część wdrożeń ogranicza zastosowanie MongoDB do niekrytycznych danych informacyjnych, powierzając obsługę krytycznych operacji relacyjnym odpowiednikom. 
MongoDB wspiera w niewielkim stopniu kodowanie UTF-8, co jest problemem w przechowywaniu tekstu w języku innym niż angielski. Do sortowania łańcuchów znaków używana jest funkcja \emph{memcmp}, która nie obsługuje poprawnie danych w UTF-8 w różnych ustawieniach regionalnych. Wprowadzenie zmian jest planowane, niestety wiąże się to -- według twórców -- z wprowadzeniem szeregu poważnych zmian. Z tego powodu termin wydania wersji z poprawną obsługą UTF-8 jest nieokreślony\cite{mongoWiki}.

\section{Warstwa prezentacji}
\subsection{HTML5}
% \section{HTML5, CSS3, less, Bootstrap, AdminLTE}

Do opisu struktury szablonów używanych przez Meteora użyto \emph{HTML5}. Wersja HTML --- HTML5 jest rozwinięciem języka HTML4 oraz jego XML-owej odmiany XHTML 1. Został on opracowany w ramach pracy grupy roboczej WHATWG\footnote{Web Hypertext Application Technology Working Group} oraz W3C. Prace nad specyfikacją zostały ukończone w 2014 roku a 28 października 2014 roku został oficjalnie wydany jako rekomendacja W3C. HTML5 poza dodaniem nowych elementów, usprawniających tworzenie serwisów oraz aplikacji internetowych, doprecyzowuje niejasności w specyfikacji HTML4, które przede wszystkim dotyczą sposobu obsługi błędów. Niejasności co do sposobu, w jaki przeglądarki powinny obsługiwać błędy w kodzie HTML są jedną z podstawowych przyczyn, dla której wiele serwisów internetowych, napisanych z naruszeniem specyfikacji, w różnych przeglądarkach działa w inny sposób -- w niektórych działając, w innych nie. Dzięki poprawnej obsłudze błędów przez przeglądarki, zły element będzie działać w każdej przeglądarce bądź w żadnej. 

HTML5 stawia także na semantykę. Element \verb|<div>| tracji na znaczeniu na rzecz elementów \verb|<header>|, \verb|<main>|,\verb|<article>|, \verb|<aside>|, \verb|<footer>|, \verb|<nav>|. Dodane zostały także następujące elementy \verb|<canvas>|, \verb|<figure>|, \verb|<details>|, \verb|<summary>|. Element \verb|<input>| zyskał dodatkowe typy: \textit{tel, search, url, email, datetime, date, month, week, time, datetime-local, number, range, color}. Dodano nowe atrybuty do elementów formularza: \textit{autofocus, required, autocomplete, min, max, multiple, pattern, step}. HTML5 ma możliwość osadzania \emph{MathML} i \emph{SVG} bezpośrednio w dokumencie\cite{htmlWiki}.

Oprócz dodania nowych elementów oraz atrybutów W3C zaproponowało większy nacisk na modułowość, określając specyficzne cechy oraz rozwój ich jako oddzielnych specyfikacji. Niektóre technologie, które pierwotnie zostały zdefiniowane w samym HTML5 są obecnie określone w odrębnych specyfikacjach. Do takich technologi należą miedzy innymi: \emph{WebGL}, \emph{Web Sockets}, rysowanie 2D z nowym elementem \verb|<canvas>|, geolokalizacja, baza danych SQL, komunikacja między stronami (np. można wysyłać informację do strony znajdującej się w ramce), \emph{microdata} (przechowywanie danych w atrybutach -- prefiks: data-), API do odtwarzania wideo i audio, API dla aplikacji offline. DOM\footnote{Obiektowy model dokumentu} zyskał dodatkowe metody: \verb|getElementsByClassName|, \verb|activeElement|, \verb|hasFocus|,\verb|getSelection|, \verb|classList| \verb|relList|\cite{htmlWiki}.

Przeglądarki obsługujące HTML5 zostaną dostosowane do obsługi błędów w składni. HTML5 został zaprojektowany tak, by starsze przeglądarki bez problemu mogły ignorować nowe konstrukcje. W przeciwieństwie do starszego HTML 4.01 specyfikacja tej wersji zawiera szczegółowe instrukcje jak postępować z niepoprawną składnią, przez co strony z błędami będą wyświetlane w ten sam sposób w różnych przeglądarkach.

\subsection{CSS3 oraz less}
Kaskadowe arkusze stylów --- CSS to język służący do opisu formy prezentacji stron WWW. CSS został opracowany przez W3C w 1996 roku. Język ten jest potomkiem języka \emph{DSSSL}. Pierwszy szkic specyfikacji CSS został zaproponowany w 1994 roku. 

CSS to lista dyrektyw -- reguł -- ustalających w jaki sposób ma zostać wyświetlona przez przeglądarkę internetową zawartość wybranego elementu (X)HTML lub XML. Można w ten sposób opisać wszystkie pojęcia odpowiedzialne za prezentację elementów dokumentu strony internetowej, takie jak rodzina czcionek, kolor tekstu, marginesy, odstępy międzywierszowe, pozycja danego elementu względem innych elementów bądź okna przeglądarki. Zastosowanie arkuszy stylów daje znacznie większe możliwości pozycjonowania elementów na stronie, niż oferuje sam HTML\cite{cssWiki}. 

CSS został stworzony w celu oddzielenia struktury dokumentu od formy jego prezentacji. Separacja zmniejsza zawiłość dokumentów, ułatwia wprowadzanie zmian w strukturze dokumentu. Arkusze stylów ułatwiają także zmiany w renderowaniu strony w zależności od obsługiwanego medium (ekran, telefon, tablet, dokument do druku). Stosowanie zewnętrznych arkuszy CSS daje możliwość zmiany wyglądu wielu stron naraz bez ingerowania w sam kod HTML, ponieważ arkusze mogą być wspólne dla wielu dokumentów. 

Pierwotnie HTML był językiem wyłącznie do opisu struktury dokumentu. Jednak z czasem zrodziła się potrzeba ożywienie wyglądu takich dokumentów. Powoli dodawano nowe znaczniki do HTML pozwalające kontrolować kolory, typografię, dodawać nowe media. Te niestandardowe rozszerzenia implementowane były przez producentów przeglądarek bez porozumienia z innymi producentami. Taka sytuacja doprowadziła do zaimplementowania nowych znaczników działających w konkretnej grupie przeglądarek i nie działających w innych przeglądarkach. Twórcy stron internetowych byli zmuszeni do wysyłania do klienta różnych wersji tej samej witryny w zależności od użytej przeglądarki. Uzyskanie identycznego wyglądu w różnych przeglądarkach było praktycznie niemożliwe. Håkon Wium Lie jako pierwszy zaproponował CHSS (Cascading HTML Style Sheets) w październiku 1994 roku. Później Lie i Bert Bos pracowali wspólnie nad standardem CSS (literka H została usunięta ze względu na możliwość stosowania stylów do innych podobnych do HTML języków). Po przejęciu prac przez, dopiero co utworzoną, organizację W3C w 1996 roku wydano oficjalną dokumentację CSS, poziomu 1\cite{cssWiki}.

Przed pojawieniem się CSS wszystkie informację dotyczące wyglądu dokumentów HTML (wygląd czcionek, ułożenie, margines itp.) zawarte były w znacznikach HTML. Język CSS umożliwił przeniesie tych informacji do osobnego pliku. Zabieg ten upraszcza oraz zwiększa przejrzystość samego dokumentu HTML. Bez użycie CSS w przypadku definiowania stylu dla danego elementu np. \verb|h1| jego definicja musiałby zostać powtórzona w każdym miejscu użycia danego elementu. Doprowadziło by to zmniejszenia czytelności dokumentu i jego odporności na błędy oraz zwiększyło by trudność jego utrzymania. Wprowadzenie zmiany w definicji stylu danego elementu wymagało by zmian w wielu miejscach dokumentu HTML. CSS umożliwia rozdzielenie warstwy prezentacji od warstwy struktury. CSS umożliwia definicję kolorów, czcionek, układu, rozmiarów, marginesów oraz wielu innych cech związanych z warstwą prezentacji.

Specyfikacja CSS3 w odróżnieniu od jej poprzedniej wersji CSS2 została podzielona na niezależne moduły. Każdy moduł zawiera nowe możliwości i rozszerza elementy zdefiniowane w CSS2, tak aby zachować kompatybilność z wersjami wcześniejszymi. Prace nad trzecim poziomem CSS rozpoczęły się krótko po oficjalnej publikacji CSS2. Najwcześniejsza wersja CSS3 pojawiła się w czerwcu 1999 roku. W wyniku podzielenia na moduły poszczególne elementy CSS3 mają różny status czy poziom stabilności. Dzięki temu podziałowi poszczególne moduły mogą być publikowane jako obowiązujące niezależnie od etapu prac nad pozostałymi elementami. CSS3 zyskał nowe znacznik i właściwości. W czerwcu 2012 roku \emph{CSS Working Group} miało opublikowanych ponad 50 różnych modułów a kilka z nich zostało oficjalnie zarekomendowanych jako standardy przez W3C np: typy mediów (\textit{media queries}, przestrzenie nazw (\textit{namespaces}, selektory (\textit{selectors}), kolory\cite{cssWiki}.

Niektóre z modułów, na przykład tła i obramowania czy układ wielokolumnowy, mają nadany status CR (\textit{Candidate Recommendation}), który uważany jest za raczej stabilny. Dostawcy przeglądarek internetowych powinni zatem sukcesywnie poprawiać dotychczasowe implementacje w celu usuwania tzw. prefiksów dostawców (\textit{vendor prefix}) w nazwach właściwości. Czyli zamiast \verb|-moz-border-radius| dla silnika \emph{Gecko}, \verb|-webkit-boerder-radius| dla sinika \emph{WebKit}, powinno zostać zaimplementowane \verb|border-radius|.

Less (\emph{Leaner CSS}) to dynamiczny język arkuszy stylów stworzony przez Alexis Salliera. Został stowrzony w odpowiedzi na język \emph{Sass} oraz dał początek nowszej wersji Sass - \emph{SCSS}, która zapożyczyła cześć jego składni. Less było początkowo oprogramowaniem open source opartym na licencji MIT, którą zmieniono później na Apache License 2.0. Pierwsza implementacja napisana została w Ruby, późnej została ona zastąpiona wersją napisaną w JavaScript. Less jest zagnieżdżonym metajęzykiem -- poprawny kod CSS jest również poprawnym kodem Less. Less dostarcza takie mechanizmy jak zmienne, zagnieżdżanie, mixiny, operatory oraz funkcje. Less może działać zarówno po stronie klienta, jak i serwera, jak również jego kod może być skompilowany do czystego CSS. 

Meteor po zainstalowaniu paczki \verb|less| automatycznie kompiluje pliki \verb|.less| do CSS a rezultat jest dołączany do pozostałych plików CSS.

\subsection{Bootstrap}

Bootstrap jest to wolna oraz otwarto źródłowa kolekcja narzędzi do tworzenia stron internetowych oraz aplikacji sieciowych. Zawiera szablony projektowe oparte o HTML oraz CSS dla typografii, formularzy, nawigacji, oraz innych elementów interfejsu użytkownika zawiera ona także opcjonalne rozszerzenia napisane w JavaScript. Głównym celem frameworka jest ułatwienie tworzenia aplikacji sieciowych jaki i  dynamicznych stron internetowych. Jest to framework front-endowy\footnote{Front-end jest odpowiedzialny za pobieranie danych od użytkownika oraz przekazanie ich do back-endu. Następnie back-end na podstawie tych danych wykonuje określone zadanie.} stanowi on podstawę interfejsu użytkownika\cite{bsWiki}.

Bootstrap został stowrzony przez Marka Otta oraz Jacoba Thortona jako framework na potrzeby wewnętrznych projektów w Twitterze, które były budowane z wykorzystaniem różnych bibliotek na potrzeby interfejsu użytkownika. Początkowo nazywany był jako \emph{Twitter Blueprint}. Bootstrap został wydany 19 sierpnia 2011 jako projekt otwarto źródłowy. Projekt jest utrzymywany oraz rozwijany przez Marka Otta, Jacoba Thortona z małą grupą programistów rdzenia frameworka oraz przez dużą społeczność programistów. Następna wersja Bootstrap 2 został wydana 31 stycznia 2012. Obecna wersja Bootstrap 3 została wydana 19 sierpnia 2013 roku. W tej wersji położono nacisk na urządzenia mobilne oraz płaskie projektowanie\footnote{Styl projektowania grafiki zakładający wyeliminowanie takich elementów jak gradienty i cieniowanie, ograniczenie liczby kolorów i stosowanie tylko prostych kształtów i typografii}\cite{bsWiki}.

Bootstrap jest kompatybilny z najnowszymi wersjami przeglądarek Google Chrome, Firefox, Internet Explorer, Opera oraz Safari. Od wersji 2.0 framework wspiera także \emph{responsive web design} --- responsywność\footnote{Technika projektowania strony www, tak aby jej wygląd i układ dostosowywał się automatycznie do rozmiaru okna urządzenia, na którym jest wyświetlany np. przeglądarki, smartfonów czy tabletów[1]. Strona tworzona w takiej technice jest uniwersalna i wyświetla się dobrze zarówno na dużych ekranach, jak i na smartfonach czy tabletach.} --- wygląd strony internetowej dynamicznie zmienia się w zależności od charakterystyki użytego urządzenia (komputer, tablet, telefon).

\subsection{AdminLTE}

AdminLTE jest to otwarto źródłowy szablon dla aplikacji sieciowych do tworzenia paneli administracyjnych lub paneli kontrolnych. Szablon oparty jest o framework Bootstrap 3. Wykorzystuje wszystkie komponenty zawarte w frameworku Bootstrap wraz z ich wygląd oraz przeprojektowując wygląd wielu często używanych wtyczek w celu stworzenia spójnego wyglądu interfejsu użytkownika. AdminLTE zbudowany jest w oparciu o moduły, co pozwala na jego łatwe dostosowanie do wymagań oraz rozszerzanie o nowe funkcjonalności.

\section{System kontroli wersji}

Jako system kontroli wersji został użyty \emph{Git}. Git jest to rozproszony system kontroli wersji. Został stworzony przez Linusa Torvaldsa jako narzędzie wspierające rozwój jądra Linux. Git jest to wolne oprogramowanie i został opublikowany na licencji GNU GPL w wersji 2. Najważniejsze cechy Git to: 
\begin{itemize}
 \item dobre wsparcie dla rozgałęzionego procesu tworzenia oprogramowania --- jest dostępnych kilka algorytmów łączenie zmian z dwóch gałęzi, a także można dodawać własne algorytmy;
 \item praca off-line --- każdy z programistów posiada własną kopię repozytorium, do której może zapisywać zmiany bez połączenia z siecią, następnie zmiany mogą być wymieniane między lokalnymi repozytoriami;
 \item wsparcie dla istniejących protokołów sieciowych --- dane można wymieniać przez HTTP/HTTPS, FTP, rsync, SSH;
 \item efektywna praca z dużymi projektami --- system Git według zapewnień Torvaldsa, a także według testów fundacji Mozilla, jest o rzędy wielkości szybszy niż niektóre konkurencyjne rozwiązania;
 \item każda rewizja to obraz całego projektu --- w przeciwieństwie do innych systemów kontroli wersji, Git nie zapamiętuje zmian między kolejnymi rewizjami, lecz kompletne obrazy, wymaga to nieco więcej pracy aby porównać dwie rewizje, lecz pozwala na przykład na automatyczną obsługę zmian nazw plików.
\end{itemize}

Jako hosting dla repozytorium projektu został wykorzystany \emph{GitHub}\footnote{\url{https://github.com}}. GitHub to hostingowy serwis internetowy przeznaczony dla projektów programistycznych wykorzystujących system kontroli wersji Git. Stworzony został przy wykorzystaniu frameworka Ruby on Rails i języka Erlang. Serwis działa od kwietnia 2008 roku. W kwietniu 2011 roku ogłoszono, iż GitHub obsługuję 2 miliony repozytoriów. GitHub udostępnia darmowy hosting programów otwarto źródłowych oraz płatne prywatne repozytoria.
Repozytorium dla projektu napisanego na potrzeby niniejszej pracy dyplomowej znajduje się pod adresem \url{https://github.com/yp2/intranet}.
