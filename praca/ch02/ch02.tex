Rozdział ten przedstawia wykorzystane technologie oraz języki programowania użyte podczas projektowania oraz programowania aplikacji Intranet. Aplikacja powstała z wykorzystaniem \emph{JavaScript}, framework aplikacji sieciowych \emph{Meteor.js}, nierelacyjnej bazy danych  \emph{MongoDB} oraz framework'a CSS \emph{Bootstrap}, \emph{HTML5}, \emph{CSS3}, \emph{less} --- dynamiczny jeżyk arkuszy stylów oraz gotowy szablon dla panelu administracyjnego \emph{AdminLTE} wykorzystujący Bootstrap.

\section{JavaScript}

Język programowania JavaScript został użyty do zaprogramowania zarówno części serwerowej (\textit{back-end}) jaki i części odpowiedzialnej za interakcje z użytkownikiem (\textit{front-end}) --- interfejs użytkownika. Obecne strony WWW a w szczególności aplikacje dostępne przez przeglądarkę (Gmail, Google Docs, Google Maps, Facebook) szeroko korzystają z~JavaScript w celu dostarczenie wielofunkcyjnego oraz interaktywnego interfejsu użytkownika. Jednym z powodów wykorzystanie JavaScript była możliwości wykorzystania go po stornie serwera oraz klienta. Najpopularniejszy obecnie sposób tworzenia stron/aplikacji internetowych wyróżnia trzy warstwy --- warstwę struktury (HTML), warstwę prezentacji (CSS) oraz warstwę zachowania (JavaScript)\cite{stefanov10}.

Internet powstał jako zbiór statycznych dokumentów HTML, które były powiązane hiperłączami. Po wzroście popularności oraz rozmiaru sieci, autorom stron przestały wystarczać dostępne narzędzia. Widoczna stała się potrzeba poprawienia interakcji z~użytkownikiem. U jej podstaw leżała chęć zmniejszenie ilości połączeń z serwerem w celu realizowania prostych zadań takich jak walidacja formularzy. W tym czasie pojawiły się dwie możliwości - aplety Javy oraz język \emph{LiveScript}, który został zaproponowany przez firmę Netscape w roku 1995. Został on dołączony do przeglądarki Netscape 2.0 pod nazwą JavaScript\cite{stefanov10}.  

Możliwość zmieniania statycznych elementów stron internetowych została bardzo szybko przyjęta przez rynek. Producenci przeglądarek internetowych szybko dostosowani swoje produktu do obsługi JavaScript'u. Microsoft wyposażył w taką obsługę swoją przeglądarkę Internet Explorer (IE) od wersji 3.0. Jednak była to kopia języka JavaScript --- \emph{JScript}, wzbogacona o kilka funkcjonalności przeznaczonych tylko dla IE. W wyniku coraz większych różnić pomiędzy przeglądarkami podjęto próbę standaryzacji różnych implementacji języka. Próbę tą podjęło Europejskie Stowarzyszenie na rzecz Systemów Informatycznych i Komunikacyjnych (ECMA). Została stworzona specyfikacja ECMAScript. Obecnie obowiązuje standard ECMA-262\cite{ecmascriptWiki} --- JavaScript jest jego najpopularniejszą implementacja.  

Wzrost popularności JavaScriptu miał miejsce w czasie Pierwszej Wojny Przeglądarek (1996-2001)\cite{stefanov10}. Było to także okres tak zwanej bańki internetowej. W tym czasie o udział w rynku walczyli dwaj główni producenci przeglądarek Netscape oraz Microsoft. Firmy te kusiły klientów za pomocą coraz to nowych dodatków i ozdóbek wprowadzanych do przeglądarek oraz do stosowanych w nich wersji JavaScriptu. W tym czasie wiele osób wyrobiło sobie negatywną opinie na temat tego języka, który w wyniku wspomnianych działań oraz braku standaryzacji bez przerwy ulegał modyfikacją. Pisanie programów było koszmarem. Skrypty napisane w oparciu o jedną przeglądarkę nie chciały nie chciały działać w drugiej. Producenci przeglądarek, skupieni na rozszerzaniu o nowe funkcjonalności, nie dostarczali odpowiednich narzędzi do rozwijania aplikacji\cite{stefanov10}.

Niespójności pomiędzy przeglądarkami była tylko częścią problemu. Drugą częścią byli sami autorzy stron, którzy upychali w witrynach zbyt wiele zbędnych funkcjonalności. Bardzo często korzystali z wszystkich nowych możliwości dostarczanych przez przeglądarkę, przez co strony były ,,upiększane'' o kwiatki takie jak animacje na pasku stanu, jaskrawe kolory, migające napisy, trzęsące się okna przeglądarek, płatki śniegu, obiekty podążające za kursorem itp., bardzo często utrudniało korzystanie ze stron. Tego typu nadużycia są także powodem złej reputacji JavaScriptu. Problemy te doprowadziły do traktowania języka JavaScript za niewiele więcej niż zabawkę przeznaczoną dla projektantów interfejsów. 

% Sprzeciw wobec JavaScriptu doprowadził do sytuacji, w której w niektórych projektach sieciowych zabronione zostało jakiekolwiek programowanie po stronie klienta. Wszystkie funkcjonalności miał obsługiwać przewidywalny i wiarygodny serwer.

Po zakończeniu Pierwszej Wojny Przeglądarek sposób wytwarzania aplikacji sieciowych uległ zmianie. Zmiany --- na lepsze --- zostały zapoczątkowane przez kilka procesów\cite{stefanov10}: 
\begin{itemize}
 \item Microsoft wygrał wojnę i na okres około pięciu lata wstrzymał się od dodawania nowych funkcjonalności do przeglądarki Internet Explorer oraz do samego JavaScriptu. Dzięki temu producenci innych przeglądarek zyskali czas na dogonienie a czasem nawet przewyższenie możliwości IE.
 \item Ruch na rzecz standardów sieciowych zyskał przychylność programistów jaki i producentów przeglądarek. Standardy chronią programistów od konieczności programowania funkcjonalności dwa (lub więcej) razy na wypadek, gdyby coś nie działało, w którejś z przeglądarek. Co prawda nadal nie istnieje środowisko, które spełniało by wszystkie możliwe standardy.
 \item technologie i sposoby programowania osiągnęły bardzo dojrzały poziom, na którym można już zajmować się zagadnieniami takim jak użyteczność, dostępność czy też progresywne ulepszanie. 
\end{itemize}
Dzięki nowym, zdrowszym metodologiom programiści zaczęli uczyć się lepszych sposób korzystania z już dostępnych narzędzi. Po wydaniu aplikacji takich jak \emph{Gmail} czy \emph{Google Maps}, które w bardzo szerokim stopniu wykorzystują programowanie po stronie klienta, oczywiste stało się, że JavaScript to dojrzały, jedyny w swoim rodzaju i potężny prototypowy język obiektowy\cite{stefanov10}. Dobrym przykładem jego ponownego odkrycia jest szeroka akceptacja funkcjonalności dostarczanej przez obiekt \jsinline{XMLHttpRequest}, który dawniej był obsługiwany tylko przez przeglądarkę Internet Explorer. Obiekt ten jednak został zaimplementowany przez wiele przeglądarek. \jsinline{XMLHttpRequest} umożliwia wykonywanie żądań HTTP i pobieranie zawartości serwera w celu aktualizacji pewnych części strony bez konieczności przeładowanie jej całej. Dzięki temu narodził się nowy gatunek aplikacji sieciowych, które przypominają samodzielne aplikacje desktopowe. Takie aplikacje określamy mianem \emph{AJAX}.

JavaScript po rewolucji spowodowanej rozwojem technologii AJAX zaczął być używany przez programistów do tworzenia rzeczywistych i ważnych aplikacji. Obecnie mamy wiele aplikacji sieciowych JavaScript począwszy od Twittera, przez Facebook, aż po GitHub\cite{cantelon14}. Jedną z ciekawszych cech JavaScriptu jest to, że musi on działać wewnątrz \emph{środowiska}. Najpopularniejszym środowiskiem jest przeglądarka internetowa. Istnieją także inne możliwości --- JavaScript może działać po stornie serwera, na pulpicie lub wewnątrz tzw. \emph{rich media}\footnote{Aplikacje \textit{rich media} --- Flash, Flex --- tworzy się przy użyciu ActionScriptu, który jest oparty o ECMAScript}. 

Od chwili wydania przeglądarki Google Chrome w roku 2008 ciągle oraz w bardzo szybkim tempie poprawia się wydajność działania JavaScript, co jest wynikiem silnej konkurencji pomiędzy producentami poszczególnych przeglądarek internetowych. Wydajność nowoczesnych maszyn wirtualnych JavaScript zmienia rodzaje aplikacji tworzonych dla sieci. Fantastycznym przykładem jest jslinux\footnote{\url{http://bellard.org/jslinux/}} --- utworzony w JavaScript emulator pozwalający na wczytanie jądra systemu Linux, pracę w powłoce oraz kompilację programów w C.

\subsection{Przegląd cech JavaScript}

JavaScript jest językiem programowania imperatywnym oraz strukturalnym. Wspiera większość składni programowania strukturalnego z języka C, np. pętle \verb|while|, instrukcję wyboru \verb|switch|, pętle \verb|do while| oraz wiele innych. Wyjątkiem jest zasięg zmiennych. W JavaScript zasięg zmiennych z wykorzystaniem słowa kluczowego \verb|var| to zasięg do całego ciała funkcji. Nowy standard ECMAScript 2015 (ES6) wprowadza zakres zmiennych co do bloku instrukcji z wykorzystaniem słowa kluczowego \verb|let| --- co oznacza że język ten ma obecnie zakres zmiennych co do ciała funkcji jak i do bloku instrukcji. Podobnie jak C JavaScript rozróżnia wyrażenia oraz instrukcji\cite{jsWiki}. 

Jak większość języków skryptowych także JavaScript jest językiem dynamicznie typowanym. Typy powiązane są z wartościami a nie ze zmiennymi. Na przykład do zmiennej x może być przypisana wartość typu liczbowego a następnie możemy do takiej zmiennej przypisać na przykład łańcuch znaków\cite{jsWiki}. 

JavaScript jest prawie w całości obiektowy. Obiekty w JavaScript są to tablice asocjacyjne rozszerzone o prototypy. Nazwy właściwości obiektu to ciągi znaków. Obiekty wspierają dwie różnoznaczne składnie --- z kropką \verb|obj.x = 10| oraz z nawiasami kwadratowymi \verb|obj["x"] = 10|. Właściwości oraz ich wartości mogą być dodawane, zmienianie oraz usuwane w każdej chwili działania programu. Większość właściwości obiektu ( oraz te dziedziczone w łańcuch prototypów) mogą być wymienione z wykorzystaniem pętli \verb|for ... in|. JavaScript ma dość skromny wachlarz obiektów wbudowanych, między innymi funkcje \verb|Function|  oraz obiekty daty --- \verb|Date|. JavaScript oferuje również wbudowaną funkcje \verb|eval|, która może wykonywać instrukcje dostarczone w postaci ciągów znaków podczas działania programu\cite{jsWiki}. 

JavaScript jest także językiem funkcyjnym. Funkcję są typu pierwszej klasy. Oznacza to, że JavaScript wspiera przekazywanie funkcji jako argumentów do innych funkcji, zwracania ich jako wartości innych funkcji, przypisywania ich do zmiennych oraz zapisywanie ich w strukturach danych. JavaScript wspiera również funkcje anonimowe\cite{fcfunctionWiki}. Funkcje w JavaScript jako takie posiadają właściwości oraz metody takie jak \verb|.call()| i \verb|bind|. Funkcje zagnieżdżone to funkcje zdefiniowane wewnątrz innych funkcji. Funkcja taka jest każdorazowo tworzona podczas wywołania funkcji zewnętrznej, w której została ona zdefiniowana. Dodatkowo każda tworzona funkcja tworzy \emph{domkniecie}: zasięg zmiennych funkcji zewnętrznej, włączając w to zmienne lokalne oraz wartości argumentów, stają się częścią wewnętrznego stanu każdego wewnętrznego obiektu funkcji, nawet po zakończeniu wykonywania zewnętrznej funkcji\cite{jsWiki}.

JavaScript wykorzystuje prototypy, w odróżnieniu od innych języków zorientowanych obiektowo wykorzystujących klasy, w procesie dziedziczenia. W JavaScript można za symulować wiele cech dziedziczenia opartego na klasach wykorzystując prototypy\cite{jsWiki}. Nowe wydanie ES6 wprowadza do JavaScript składnie umożliwiającą definiowanie klas.  

Funkcje obok swojej typowej roli w JavaScript mogą także tworzyć obiekty. Poprzedzając wywołanie funkcji instrukcją wbudowaną \verb|new| zostanie utworzona instancja prototypu dziedzicząca właściwości oraz metody z konstruktora (włączając w to właściwości z prototypu obiektu wbudowanego \verb|Object|). ECMAScript 5 oferuje metodę \verb|Object.create| pozwalającą na jawne tworzenie instancji bez automatycznego dziedziczenia z prototypu \verb|Object|. Właściwość \verb|prototype| konstruktora określa jaki obiekt zostanie użyty jako wewnętrzny prototyp nowo utworzonego obiektu. Nowe metody mogą zostać dodane poprzez modyfikowanie prototypu funkcji użytej jako konstruktor. Wbudowane konstruktory takie jak \verb|Array| lub \verb|Object|, także posiadają prototyp, który może być modyfikowany. Modyfikowanie prototypy \verb|Object| jest uznawane za złą praktykę ponieważ prawie wszystkie obiekty w JavaScript dziedziczą metody oraz właściwości z prototypu obiektu \verb|Object|\cite{jsWiki}.

W odróżnieniu od wielu języków zorientowanych obiektowo w JavaScript nie ma różnicy pomiędzy definicją funkcji oraz definicją metody. Różnica pojawia się podczas wywołania funkcji oraz metody. Kiedy funkcja wywoływana jest jako metoda obiektu, słowo kluczowe \verb|this| wewnątrz ciała funkcji jest powiązane z obiektem na rzecz, którego dana metoda została wywołana\cite{jsWiki}. 

JavaScript posiada wbudowane implementacje, opartą na funkcjach, wzorców takich jak \textit{cecha} oraz \textit{domieszka}. Jawna, oparta na funkcjach, delegacja nie wspiera kompozycji, to natomiast nie jawna delegacja ujawnia się za każdym razem gdy przechodzony jest łańcuch prototyp np. w celu znalezienia metody, która nie należy bezpośrednio do obiektu. Gdy metoda zostanie odnaleziona wywoływana jest w kontekście danego obiektu. Dlatego dziedzinie w JavaScript jest realizowane przez delegacje, która to przypisana jest to właściwości prototyp konstruktora funkcji\cite{jsWiki}.

Typo JavaScript uruchamiany jest w jakimś środowisku np. przeglądarka internetowa, które dostarcza obiekty oraz metody, przez które uruchamiany skrypt może oddziaływać na środowisko np. obiekt DOM strony internetowej. 

JavaScript przetwarza wiadomości z kolejka po jednej na raz. Podczas ładowania nowej wiadomości, JavaScript wywołuje funkcję powiązaną z daną wiadomości tworząc ramkę stosu wywołania (są to argumenty funkcji oraz zmienne lokalne). Stos wywołania zmniejsza się oraz powiększa zgodnie z potrzebami wywołanej funkcji. Nazwane jest to pętlą zdarzeń, opisywaną także jako ,,działaj do ukończenia'', ponieważ każda wiadomość jest całkowicie przetwarzana zanim przejdziemy do kolejnej wiadomości. Jednakże wbudowany model konkurencji nadaje pętli zdarzeń charakter nie blokujący. Operacje wejścia/wyjścia realizowane są z użyciem zdarzeń oraz wywołań zwrotnych (funkcji zwrotnych). Oznacza to, że JavaScript może przetworzyć kliknięcie myszy podczas czekania na dane z zapytania do bazy danych\cite{jsWiki}

Do funkcji może zostać przekazana nie określona ilość argumentów. Funkcja ma do nich dostęp poprzez parametry oraz także przez lokalny obiekt \verb|arguments|\cite{jsWiki}.

Jak wiele języków skryptowych, tablice jak i obiekty mogą zostać utworzone przez zwięzłą składnie. Te literały stanowią także podstawę formatu \emph{JSON}\footnote{JavaScript Object Notation - lekki format wymiany danych komputerowych, jest to format tekstowy. Opisany w RFC 4627}\cite{jsWiki}.

JavaScript wspiera również wyrażenia regularne w sposób podobny do \emph{Perl}, z zwięzła oraz bogatą składnią do manipulowania tekstem, znacznie bardziej zaawansowaną niż wbudowane funkcje do obróbki łańcuchów znaków.

\section{Meteor.js oraz MongoDB}

Meteor.js (Meteor, MeteorJS) jest to otwarto źródłowy framework aplikacji sieciowych napisany w JavaScript z wykorzystaniem \emph{Node.js}. Meteor pozwala na szybkie prototypowanie oraz tworzenie między platformowego kodu (aplikacje sieciowe, Android, iOS). Wykorzystuje \emph{MongoDB} oraz używa protokołu \emph{DDP}\footnote{Distributed Data Protocol - protokół klient--serwer dla zapytań oraz aktualizacji bazy danych po stronie serwera oraz synchronizacji tych aktualizacji wśród innych klientów} oraz wzorca \emph{publikacji i subskrypcji} do automatycznej propagacji zmian w danych do klientów bez potrzeby pisanie kodu synchronizującego taką propagację. Po stronie klienta, Meteor wykorzystuje \emph{jQuery}. Meteor jest rozwijany prze \textit{Meteor Development Group}. Meteor po raz pierwszy został publicznie pokazany w grudniu 2011 pod nazwą \textit{Skybreak}\cite{meteorWiki}.

Meteor jest niepokojącą (w dobrym znaczeniu) technologią. Umożliwia` budowanie aplikacji nowego typu, które są szybsze oraz prostsze w tworzeniu. Wykorzystuje nowoczesne techniki takie jak reaktywność po stronie klienta oraz serwera (\textit{Full Stack Reactivity}), kompensacja opóźnień (\textit{Latency Compensation}) oraz \textit{data on the wire} - Meteor nie wysyła danych w postaci HTML serwer wysyła dane i pozwala klientowi je renderować\cite{strack15}.

Nasz świat się zmienia. Rzeczy, które nie były możliwe kilka lata temu dzięki kolejnym postępom w dziedzinach takich jak wyświetlacze, technologie informatyczne oraz pojemności nośników danych dziś są nie tylko możliwe ale wręcz niezbędne aby aplikacja odniosła sukces. 

Meteor pozostaje wierny następującym zasadom\cite{meteorDocs}: 
\begin{itemize}
 \item \textit{Data on the Wire} --- Meteor nie wysyła HTML przez sieć. Serwer wysyła dane i pozwala klientowi je renderować.
 \item \textit{Jeden język} --- Meteor pozwala pisać stronę klienta jak i serwera w języku JavaScript.
 \item \textit{Wszechobecna baza danych} --- Meteor pozwala na użycie tych samych metod dostępu do danych po stronie klienta oraz serwera.
 \item \textit{Kompensacja opóźnień} --- Po stronie klienta Meteor wstępnie pobiera dane oraz symuluje modele aby wykonywane metody serwerowe zwracały wynik natychmiast.
 \item \textit{Korzysta z ekosystemu} --- Meteor jest projektem otwarto źródłowym (open source) oraz integruje się z istniejącymi otwarto źródłowymi narzędziami oraz frameworkami.
 \item \textit{Prostota to produktywność} --- Najlepszym sposobem aby coś wyglądało na proste to zrobić to tak aby było proste. Główne funkcjonalności Meteora mają czyste, klasycznie piękne API.
\end{itemize}

Koncepcja ,,danych w kablu`` \emph{Data On the Wire} jest bardzo prosta i powstała z zagnieżdżonego wzorca model -- widok -- kontroler --- \textit{MVC}. Zamiast przetwarzania przez serwer każdego żądania, renderowania treści i wysyłania HTML do klienta, serwer wysyła same dane i pozowana klientowi zdecydować co z nimi zrobić\cite{strack15}.

To rozwiązanie w Meteorze zostało zaimplementowane z użyciem \emph{Distributed Data Protocol} (DDP) --- protokołu klient -- serwer dla zapytań oraz aktualizacji danych po stronie serwera w bazie danych oraz synchronizacji tych zmian pośród innych klientów. Protokół ten oparty jest o składnie JSON oraz komunikuje się z serwerem w sposób podobny do protokołu \emph{REST}\footnote{Representational State Transfer - (zmiana stanu poprzez reprezentacje) --- styl architektury oprogramowania powstały z doświadczeń podczas opracowywania specyfikacji protokołu HTTP dla systemów rozproszonych. REST wykorzystuje między innymi jednorodny interfejs, bezstanową komunikację, zasoby, reprezentacje, hipermedia\cite{restWiki}}. Dodawanie, usuwanie oraz aktualizację są rozsyłane przez sieć oraz obsługiwane przez docelowe urządzenia, usługi oraz klientów. DDP używa \emph{WebSockets}\footnote{Technologia zapewniająca dwukierunkowy kanał komunikacji za pośrednictwem jednego gniazda TCP. Stworzona głównie jako kanał komunikacji pomiędzy przeglądarką internetową a serwerem internetowym. Może być także stosowana w innych aplikacjach typu klient lub serwer.\cite{wsWiki}} zamiast HTTP, dane pomogą być wysyłane kiedy tylko dane ulegną modyfikacji\cite{strack15}.


Jedną z najważniejszych cech Meteora jest reaktywność. Po stornie klienta, Meteor oferuje bibliotekę \emph{Blaze}, która używa szablonów HTML oraz \emph{helper'ów}\footnote{Pomocniczy kod JavaScript głównie zwracający wartości do szablonu HTML} JavaScript do wykrywania zmian oraz renderowania danych. Kiedy dane zostaną zmienione, helpery same ponowienie się uruchamiają zmieniając, usuwając lub dodając właściwe elementy interfejsu użytkownika na podstawie struktury zapisanej w szablonach. Funkcje, które same ponownie się uruchamiają zaliczane są do \emph{reaktywnych obliczeń}\cite{strack15}.  

Meteor oferuje reaktywne obliczenia zarówno po stronie serwera jak i klienta, bez potrzeby odwoływania się do interfejsu użytkownika. Wchodząca w skład framework'a biblioteka \emph{Tracker} oraz jej helpery także wykrywają zmiany w danych oraz potrafią się same ponownie uruchomić. Ponieważ JavaScript używane jest po stronie serwera oraz klienta, bibliotekę Tracker można używać po obu stronach. Ponieważ używamy tego samego języka po stronie klienta (oraz możemy używać tego samego kod) jak i serwera nazywamy to \emph{full stack reactivity} - reaktywność po stronie klienta jak i serwera\cite{strack15}.

Ponowne uruchamianie funkcji gdy dane ulegną zmianie ma bardzo dużą zaletę dla programisty. Kod pisany jest deklaratywnie, Meteor sam zajmuję się reaktywnością. Programista określa jak dane mają byś wyświetlane a Meteor sam zajmuję się zmianami w danych. Ten deklaratywny sposób pisanie, zazwyczaj osiągany jest z wykorzystaniem szablonów. Szablony działają w oparciu o wiązanie danych z widokiem\footnote{View data bindings} --- współdzielone dane, które w zależności od zmian będą przedstawiane w różny sposób\cite{strack15}. 


